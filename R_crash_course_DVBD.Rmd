---
title: "Introduction to Programming in R"
subtitle: "Division of Vector-Borne Diseases"
author: "Dr. Alex Grimaudo and Dr. Carol Liu"
date: "2024-10-18"
output: html_document
---

# Download and read in data
Please navigate to this URL to download the materials we will be working with today:

https://github.com/grimaudo-at/R_crash_course_DVBD

Download all of the contents of this GitHub repository in a .zip file and save in a location you can readily access on your device. After decompressing the .zip file, open the R project (*R_crash_course_DVBD.Rproj*), which will initialize a new session in R Studio. **R Projects** are useful files that set the working directory of your R session as the home folder of the Project. Therefore, below, we can simply read in our .csv file containing our data: 

```{r}
simdat <- read.csv("data_sim.csv") #We can do this...

simdat <- read.csv("C:/Users/zlh3/OneDrive - CDC/Grimaudo Personal/PE Fellowship Materials/trainings materials/R_crash_course_DVBD/data_sim.csv") #... instead of this.
```

Once you've read this file in, it should be stored as a **dataframe** object called "simdat". This dataframe is simulated data for an unspecified infectious disease. The data it contains will look similar to epidemic data collected in the real world. 

# Let's get started
First thing you should always do at the beginning of your R session: clear your workspace! This ensures that your R environment is clean and has no objects or functions defined during previous coding sessions. Think of this as cleaning your whiteboard before you start coding. 

```{}
rm(list = ls()) # Clearing workspace
```


## Load and install packages

R Packages are the "toolkits" of the R computing world. They offer users unique tools ("functions") suited to whatever it is you want to do, from cleaning data, to building beautiful figures, to creating apps, to analyzing data and building models. Because R is open-source, *anybody* can build an R Package and make it available to the world. R comes with many packages pre-installed, but you will encounter many you will need to install yourself.

```{r}
#install.packages("tidyverse")  #Installing the package -- this will take a moment. 
#library(tidyverse)             #Loading the package. 
```

## Confused? Get help!

The R Package you just installed, *tidyverse*, is actually a collection of packages commonly used for data cleaning, wrangling, and visualization. Each of these packages contains a collection of functions, which perform unique operations. Functions always have a similar syntax: *function()*. Within the parentheses, users can define specific arguments to change how the function does its job. If you are ever confused about what a specific function does or the arguments you can pass to it, use *?* to look it up!  

```{r}
?unique()
```

Using *?* in this way pulls the R documentation for the function that was published with the most recent (installed) version of its Package. 

## Examine your data

One of the most important things to do before analyzing your data is to be familiar with its contents. Luckily, R has an assortment of functions to quickly explore your data!

```{r, results='hide',fig.keep='all'}
View(simdat)
unique(simdat$hospital) # Tells you all the unique values in the specified column ($hospital)
str(simdat) # Tells you what kind of data is contained in your dataframe
head(simdat) # Returns the first several rows of data in your dataframe
tail(simdat) # Returns the last several rows of data in your dataframe
dim(simdat) # Tells you the size of your dataframe
names(simdat) # Tells you the column names in your dataframe
nrow(simdat) # Returns the number of rows in your dataframe
ncol(simdat) # Returns the number of columns in your dataframe.
```

## Add a column to your dataframe

Often times, we want to add additional data to the dataframe we have read into the R environment. This is fairly straightforward, as long as we remember some simple notation. The money symbol ($) is how we tell R exactly which column we are referring to in a dataframe, and parentheses following a word always refers to a function. Below, I will add a column to the batdat dataframe in which I log-transform my fungal load column, gd:

```{r}
batdat$log.loads<-log10(batdat$gdL)
```

## Subset data

Another very useful thing to do in R is subsetting data. This allows us to filter down a dataframe to only look at the parts we are interested in. For example, in the batdat dataframe, what if we wanted to make a whole new dataframe that just contains the data from Myotis septentrionalis?

```{r, results='hide',fig.keep='all'}
MYSE.dat = subset(batdat, species=="MYSE") #a factor/character, so need == and quotes
head(MYSE.dat)
dim(MYSE.dat)
```

As you can see, this new dataframe only contains 12 observations from Myotis septentrionalis. What if we wanted to filter numerical data? For example, what if we only wanted data from bats that were roosting at 6 degrees celsius or warmer? 

```{r, results='hide',fig.keep='all'}
warm.temps = subset(batdat, temp>6) #a number, so no quotes
head(warm.temps)
dim(warm.temps)
```

As you can see here, this new dataframe contains 258 observations, only from bats that were found roosting at 6C or warmer. Often times, you will see code that looks a little different, but accomplishes the same thing by using brackets [ ]. Brackets are a way of telling R exactly which part of a dataframe you are referring to. We can subset our batdat dataframe in the same way we did above, but using the bracket system: 

```{r, results='hide',fig.keep='all'}
MYSE.dat = batdat[batdat$species=="MYSE",]
warm.temps = batdat[batdat$temp>6,]
```

## Summarize data using aggregate()

The function aggregate() is an extremely useful function to continue exploring your data. It allows you to summarize your dataset by applying a function to subsets of data individually. For example, say that I wanted to know what the mean log fungal load (batdat$log.loads) was on my bats for each species. The aggregate() function allows me to apply the mean() function (finds the average of data) to find a separate average value for each species:

```{r, results='hide',fig.keep='all'}
bat.summary = aggregate(log.loads~species, FUN=mean, data = batdat) #aggregate data using the mean to give fungal loads by species
bat.summary

```

## Make a histogram of a column in your data

Another useful function to visualize the shape of your data is hist(), which will make a histogram with the data that you feed it. In the example below, we will make a histogram of the raw log fungal loads (batdat$log.loads) contained in our batdat dataframe: 

```{r}
hist(batdat$log.loads)
```

## Write a .csv file

We have created several new dataframes from our original batdat dataframe. If we want to save these new dataframes as a .csv file, the function write.csv() will come in handy. In the example below, I will write the MYSE.dat dataframe as a new .csv file:

```{r}
#write.csv(MYSE.dat, "MYSE_dat.csv", row.names = F)
```