---
title: "Introduction to Programming in R"
subtitle: "Division of Vector-Borne Diseases"
author: "Dr. Alex Grimaudo and Dr. Carol Liu"
date: "2024-10-18"
output: html_document
---

# Download and read in data
Please navigate to this URL to download the materials we will be working with today:

https://github.com/grimaudo-at/R_crash_course_DVBD

Download all of the contents of this GitHub repository in a .zip file and save in a location you can readily access on your device. After decompressing the .zip file, open the R project (*R_crash_course_DVBD.Rproj*), which will initialize a new session in R Studio. **R Projects** are useful files that set the working directory of your R session as the home folder of the Project. Therefore, below, we can simply read in our .csv file containing our data: 

```{r}
simdat <- read.csv("data_sim.csv") #We can do this...

#simdat <- read.csv("C:/Users/zlh3/OneDrive - CDC/Grimaudo Personal/PE Fellowship Materials/trainings #materials/R_crash_course_DVBD/data_sim.csv") #... instead of this.
```

Once you've read this file in, it should be stored as a **dataframe** object called `simdat`. This dataframe is simulated data for an unspecified infectious disease. The data it contains will look similar to epidemic data collected in the real world. 

# Let's get started
|       First thing you should always do at the beginning of your R session: clear your workspace! This ensures that your R environment is clean and has no objects or functions defined during previous coding sessions. Think of this as cleaning your whiteboard before you start coding. 
|
|
```{}
rm(list = ls()) # Clearing workspace
```


## Load and install packages

|       R Packages are the "toolkits" of the R computing world. They offer users unique tools ("functions") suited to whatever it is you want to do, from cleaning data, to building beautiful figures, to creating apps, to analyzing data and building models. Because R is open-source, *anybody* can build an R Package and make it available to the world. R comes with many packages pre-installed, but you will encounter many you will need to install yourself. We usually only need to install packages once, although some packages may need to be updated. 
|
*Note that a # in the code comments the code out so that it will not be run.*

```{r, message=F, warning=F}
#install.packages("tidyverse")  #Installing the package -- this will take a moment. 
library(tidyverse)             #Loading the package. 
```

## Confused? Get help!

|       The R Package you just installed, *tidyverse*, is actually a collection of packages commonly used for data cleaning, wrangling, and visualization. Each of these packages contains a collection of functions, which perform unique operations. Functions always have a similar syntax: `function()`. Within the parentheses, users can define specific arguments to change how the function does its job. If you are ever confused about what a specific function does or the arguments you can pass to it, use `?` to look it up!  
|
|
```{r, results='hide', message=F}
?unique()
```

Using `?` in this way pulls the R documentation for the function that was published with the most recent (installed) version of its Package. 

## Examine your data

One of the most important things to do before analyzing your data is to be familiar with its contents. Luckily, R has an assortment of functions to quickly explore your data!

```{r, results='hide',fig.keep='all'}
View(simdat) # Opens a new tab in Rstudio to examine your dataframe
unique(simdat$hospital) # Tells you all the unique values in the specified column ($hospital)
str(simdat) # Tells you what kind of data that is contained in your dataframe
head(simdat) # Returns the first several rows of data in your dataframe
tail(simdat) # Returns the last several rows of data in your dataframe
dim(simdat) # Tells you the size of your dataframe
names(simdat) # Tells you the column names in your dataframe
nrow(simdat) # Returns the number of rows in your dataframe
ncol(simdat) # Returns the number of columns in your dataframe.
hist(simdat$age) # Returns a histogram of a column in your dataframe containing numerical data, in this case age. 
```

## Add a column to your dataframe

|       Often times, we will want to create new columns in our dataframe. This can be as simple as adding geographic metadata like country or state, or be a little more complex and use calculations made on data stored elsewhere in our dataframe. In the below chunk of code, we will add three new columns to our `simdat` dataframe: `state`, `bmi`, and `logbmi`. In each case, we will specify the new column using `\$`, which specifies a column in a dataframe in the following way: `dataframe$column`. We will then assign this column new values using the `<-` assignment operator:
|
|       For example, in our dataset, we might first be interested in specifying that all this data came from Colorado in a new `state` column. We then might be interested in calculating the body mass index (BMI) of patients. To do so, we will create a new column, `bmi`, which will take values from the `ht_cm` and `wt_kg` columns for that patient and plug them into the BMI equation. We will then create another new column, `log.bmi`, that contains the log-transformed bmi values we just created: 
|
|
```{r}
simdat$state <- "Colorado" # Creating a state column. 

# The above line of code creates the new column, 'state,' in our dataframe, 'simdat,' and fills every cell with the character "Colorado". Even though this column did not yet exist, we created it by assigning it values using the <- assignment syntax. 

simdat$bmi <- simdat$wt_kg/(simdat$ht_cm/100) #Creating a bmi column. 

# Above, we created a new column, bmi, in the simdat dataframe that contains each individual's body mass index (BMI), which is a function of their weight and height. In specifying this new column, we used the patient's height and weight data stored in separate columns in the dataframe, plugging them into the BMI equation. 

simdat$logbmi <- log10(simdat$bmi) #Creating a column of log-transformed bmi values. 

# In the above line, we used the function 'log10()', which log(base-10)-transforms numerical data passed to the function. We
# passed the data contained in the bmi column we just created to this function to log-transform it and store the results in the logbmi column. 
```

## Filter data

|       When working with our data, we often are interested in only a subset, such as that from a specific hospital. In R, there are a few different ways to subset our data in this way, including using base-R indexing syntax, the base-R `subset()` function, and the `filter()` function from the package *dplyr*. Because we are working with the *tidyverse* packages today, of which *dplyr* is a part, we will use the `filter()` function. Below, we create a new dataframe, `simdat.military`, which only contains data collected from Military Hospital:
|
|
```{r, echo=FALSE, results='hide', message=F, warning=F}
require(dplyr)
```

```{r}
simdat.military <- filter(simdat, hospital == "Military Hospital")

#In the above line, we specified the new dataframe, simdat.military, to be a subset of simdat, specifically those rows where the 'hospital' column contains a string exactly equal to "Military Hospital". 

dim(simdat.military) # As you can see, the size of our dataframe has reduced compared to simdat, indicating the subsetting worked. 
```

What if we wanted to subset instead based on some numerical value? For example, what if we wanted to just use data from individuals 18 years-old or older? We can do that, too!

```{r}
simdat.18 <- filter(simdat, age > 18) # However, this dataframe does not contain individuals exactly 18 years-old...
simdat.18 <- filter(simdat, age >= 18) # ... this one does. 
dim(simdat.18) # Looks like the subsetting was successful. 
```

## Summarize data

|       One of the most common things you will want to do with your dataset is make summaries. The *tidyverse* makes this quite simple in R, but does require syntax that is not always intuitive, including the piping operator: %>% 
|
|       In plain English, the piping operator means "and then" and is used to string together a series of commands to wrangle, re-shape, and summarize your data. In the below chunk of code, we will summarize the mean and standard deviation of patient BMI between each hospital and disease outcome (recovery or death). We will store this summary as a new dataframe, `outcome.summ`:
|
|
```{r, message=F}
# Look to the right for plain English translations. 

outcome.summ <- simdat %>% # To make a new dataframe called outcome.summ, first take simdat AND THEN...
  group_by(hospital, outcome) %>% # ... group together all of its data based on hospital and outcome AND THEN...
  summarise(bmi.mean = mean(bmi), bmi.sd = sd(bmi)) # ... summarize each group's BMI data, storing the mean in a column called "bmi.mean" and the standard deviation in a column called "bmi.sd". 

head(outcome.summ) # Give me the first 6 rows of the new dataframe. 
```

## Write a .csv file

Today, we have created several new dataframes from our original simdat dataframe. If we want to save these new dataframes as a .csv file, the function `write.csv()` will come in handy. In the example below, we will write our new BMI summary dataframe as a new .csv file:

```{r}
write.csv(outcome.summ, "bmi_summ_dat.csv", row.names = F)
# The row.names = F argument tells R to, when writing the .csv, to not include row number as a column in the spreadsheet. 
```

## Working with dates in R
Dates in R can sometimes be tricky, especially if they're in different formats.  In the dataset `simdat`, there is a column that is named `date_onset`. First, lets check what class `date_onset` is stored as.

* How can we check the class of `date_onset`?*

```{r}
class(simdat$date_onset)
```

We need to reformat `date_onset` from a character to a date class. We will use the `as.Date()` function to handle this. Currently, the format of the date variables is month/day/year so we need to tell R what the current format is. To do this, we use the `%` specifically for dates to tell R which part of the character represents day, month and year respectively. Below is some code to this. We convert `date_onset` from a character to a date, and then re-assign it to the `date_onset` column in the `simdat` dataframe. 

```{r}
#Using base R
simdat$date_onset <- as.Date(simdat$date_onset, format="%m/%d/%Y")

#Using tidyverse
simdat<- simdat%>%
          mutate(date_onset=as.Date(date_onset,format="%m/%d/%Y"))
```

We can now recheck the format of `date_onset` and visually inspect the converted `date_onset` column
```{r}
class(simdat$date_onset)
head(simdat$date_onset)
```
Ensuring dates are actually read as dates into R is important for a number of reasons. 

First, we can now filter and subset based on dates. For example, if we only want cases that had an onset date in 2014, we can subset using either base R or tidyverse. Note that any time we want R to recognize a date, we need to use `as.Date`. For example, we can't simply code`filter(date_onset<="2014-12-31")` because R would not recognize this as a date. 

```{r}
#Using base R
simdat.2014<-simdat[simdat$date_onset<=as.Date("2014-12-31"),]

#Using tidyverse
simdat.2014<- simdat%>%
                  filter(date_onset<=as.Date("2014-12-31"))
```

Second, we can now do calculations with the date variables. What if we want to know how many days it takes a case to have a known outcome after symptom onset? Which variables can we use from the `simdat` to calculate this? First, we need to convert `date_outcome` into a date variable. Then, we check that `date_outcome` is indeed a date.
```{r}
# Using base R
simdat$date_outcome<-as.Date(simdat$date_outcome, format="%m/%d/%Y")

simdat<- simdat%>%
            mutate(date_outcome=as.Date(date_outcome, format="%m/%d/%Y"))

class(simdat$date_outcome)
```

Now that both `date_onset` and `date_outcome` are dates, we can now do some math to calculate the days between the date of symptom onset and the date of outcome.

```{r eval=F}
simdat$date_outcome-simdat$date_onset
```

We can then assign this new value of days between onset and outcome as a new variable in `simdat`

```{r}
#Using base R
simdat$days_outcome_onset <- simdat$date_outcome-simdat$date_onset

#Using tidyverse
simdat <- simdat%>%
            mutate(days_outcome_onset = date_outcome-date_onset)
```

Third, we can now generate time series plots or epidemic curves over time using the date variable as an x-axis, which we will cover in the next section

## Plotting in R using ggplot()
`ggplot2` is a powerful and widely-used data visualization package in R thatâ€™s part of the tidyverse family. It is based on the idea of "Grammar of Graphics," which provides a structured and logical approach to creating plots. The key idea behind ggplot2 is that data visualization can be broken down into layers, where each layer represents a specific component or transformation of the data. This allows us to describe a plot in terms of building blocks or layers. Each plot has several sessnetial components 

* *Data*: The dataset you are visualizing.
* *Aesthetic mappings (aes)*: Describes how data variables map to visual properties like position, color, size, etc.
* *Geometries (geoms)*: Defines the type of plot, such as points (scatter plot), lines (line plot), bars (bar plot), etc.
* *Many other bells and whistles*: Controlling scales and legends, adding text, changing colors, facetting etc. 

We will first download and load the `ggplot2` package.
How will you do this?
```{r}
#install.packages("ggplot2")
#library(ggplot2)
```

Next, we will start by creating a scatter plot of age and weight, with age on the x-axis and weight on the y-axis. We will use the `ggplot()` function. First, we will specify the dataset we are using. Then we will provide the `aes()` mapping by specifying which variable we want on the x-axis and which variable on the y-axis, lastly, we specify the type of plot for R. In our case, a scatterplot is specific as `geom_point()`
```{r, warning=FALSE}
ggplot(data=simdat,              #data
        aes(x=age, y=wt_kg))+    #aes mapping of x and y axis
        geom_point()             #specifying scatter plot
```
We can now build on this plot by adding a title and providing more informative labels to the x and y axis using the functions `ggtitle()`, `xlab()` and `ylab()`. Note that in the `ggplot()` syntax, we simply `+` each separate element onto the code as we build out our plot.
```{r, warning=F}
ggplot(data=simdat,                                              #data
        aes(x=age, y=wt_kg))+                                    #aes mapping of x and y axis
        geom_point()+                                            #specifying scatter plot
        ggtitle("Scatter plot of age and weight among cases")+   #Plot title
        xlab("Age (years)")+                                     #X-axis label
        ylab("Weight (kg)")                                      #Y-axis label
  
```

Your turn! Now try to do a scatter plot with age on the x-axis and height on the y-axis. Ensure that you label your axis and plot title so it's informative!
```{r, warning=F}
ggplot(data=simdat,                                              #data
        aes(x=age, y=ht_cm))+                                    #aes mapping of x and y axis
        geom_point()+                                            #specifying scatter plot
        ggtitle("Scatter plot of age and height among cases")+   #Plot title
        xlab("Age (years)")+                                     #X-axis label
        ylab("Height (cm)")                                      #Y-axis label
```

Now we will try a different type of graph. We want to produce an epidemic curve of all cases over time. In order to do this, we first need to summarise the data so that we have the number of cases per day, by the date of onset. How can we do this?

**Hint**: the function `n()` can count the number of rows in a dataframe. (It can also count the number of elements in any object.)

```{r}
simdat.day.summ<-simdat%>%
                  group_by(date_onset)%>%
                  summarise(n_case=n())
                  
```

Now that we have our data properly summarized by the date of symptom onset, we can now proceed with producing an epidemic curve. 
```{r, warning=F}

ggplot(data=simdat.day.summ,                                              #data
        aes(x=date_onset, y=n_case))+                                    #aes mapping of x and y axis
        geom_col()                                                      #specifying bar plot

```

Get creative! Try to figure out how we can modify the plot above:

**Hint** Try googling or looking at the package vignette for the `ggplot2` package
* Add plot title, x-axis label and y-axis label
* Change the colors of the bars
* Increase the y-axis so it has a maximum of 80
* Change the background to a black white theme



```{r, warning=F}
ggplot(data=simdat.day.summ,                                             #data
        aes(x=date_onset, y=n_case))+                                    #aes mapping of x and y axis
        geom_col(color="darkblue")+                                      #specifying bar plot  
        ggtitle("Epidemic curve by date of symptom onset")+              #Plot title
          xlab("Date")+                                                  #X-axis label
          ylab("Number of cases")+                                       #Y-axis label
          ylim(0,80)+                                                    #setting limits of y-axis
          theme_bw()                                                     #specifying a theme
```

What if we wanted a line graph?

```{r, warning=F}
ggplot(data=simdat.day.summ,                                             #data
        aes(x=date_onset, y=n_case))+                                    #aes mapping of x and y axis
        geom_line(color="darkblue")+                                     #specifying line plot  
        ggtitle("Epidemic curve by date of symptom onset")+              #Plot title
          xlab("Date")+                                                  #X-axis label
          ylab("Number of cases")+                                       #Y-axis label
        ylim(0,80)+                                                      #setting y-axis limits
        theme_bw()                                                       #specifying a theme
```

Challenge! Replicate the following plot

```{r, warning=F, echo=F, message=F}
simdat.day.gend.summ<-simdat%>%
                  group_by(date_onset,gender)%>%
                  summarise(n_case=n())

ggplot(data=simdat.day.gend.summ,                                              #data
        aes(x=date_onset, y=n_case, color=gender))+                            #aes mapping of x and y axis
        geom_line()+                                                           #specifying bar plot  
        ggtitle("Epidemic curve by date of symptom onset and gender")+         #Plot title
          xlab("Date")+                                                        #X-axis label
          ylab("Number of cases")+                                             #Y-axis label
          ylim(0,50)+                                                          #setting y-axis limits
          theme_bw()                                                           #specifying a theme

```


```{r}
print("Congratulations, you've completed the workshop!")
```

