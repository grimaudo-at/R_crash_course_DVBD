---
title: "Introduction to Programming in R"
subtitle: "Division of Vector-Borne Diseases"
author: "Dr. Alex Grimaudo and Dr. Carol Liu"
date: "2024-10-18"
output: html_document
---

# Download and read in data
Please navigate to this URL to download the materials we will be working with today:

https://github.com/grimaudo-at/R_crash_course_DVBD

Download all of the contents of this GitHub repository in a .zip file and save in a location you can readily access on your device. After decompressing the .zip file, open the R project (*R_crash_course_DVBD.Rproj*), which will initialize a new session in R Studio. **R Projects** are useful files that set the working directory of your R session as the home folder of the Project. Therefore, below, we can simply read in our .csv file containing our data: 

```{r}
simdat <- read.csv("data_sim.csv") #We can do this...

simdat <- read.csv("C:/Users/zlh3/OneDrive - CDC/Grimaudo Personal/PE Fellowship Materials/trainings materials/R_crash_course_DVBD/data_sim.csv") #... instead of this.
```

Once you've read this file in, it should be stored as a **dataframe** object called "simdat". This dataframe is simulated data for an unspecified infectious disease. The data it contains will look similar to epidemic data collected in the real world. 

# Let's get started
First thing you should always do at the beginning of your R session: clear your workspace! This ensures that your R environment is clean and has no objects or functions defined during previous coding sessions. Think of this as cleaning your whiteboard before you start coding. 

```{}
rm(list = ls()) # Clearing workspace
```


## Load and install packages

R Packages are the "toolkits" of the R computing world. They offer users unique tools ("functions") suited to whatever it is you want to do, from cleaning data, to building beautiful figures, to creating apps, to analyzing data and building models. Because R is open-source, *anybody* can build an R Package and make it available to the world. R comes with many packages pre-installed, but you will encounter many you will need to install yourself.

```{r}
#install.packages("tidyverse")  #Installing the package -- this will take a moment. 
#library(tidyverse)             #Loading the package. 
```

## Confused? Get help!

The R Package you just installed, *tidyverse*, is actually a collection of packages commonly used for data cleaning, wrangling, and visualization. Each of these packages contains a collection of functions, which perform unique operations. Functions always have a similar syntax: *function()*. Within the parentheses, users can define specific arguments to change how the function does its job. If you are ever confused about what a specific function does or the arguments you can pass to it, use *?* to look it up!  

```{r}
?unique()
```

Using *?* in this way pulls the R documentation for the function that was published with the most recent (installed) version of its Package. 

## Examine your data

One of the most important things to do before analyzing your data is to be familiar with its contents. Luckily, R has an assortment of functions to quickly explore your data!

```{r, results='hide',fig.keep='all'}
View(simdat)
unique(simdat$hospital) # Tells you all the unique values in the specified column ($hospital)
str(simdat) # Tells you what kind of data is contained in your dataframe
head(simdat) # Returns the first several rows of data in your dataframe
tail(simdat) # Returns the last several rows of data in your dataframe
dim(simdat) # Tells you the size of your dataframe
names(simdat) # Tells you the column names in your dataframe
nrow(simdat) # Returns the number of rows in your dataframe
ncol(simdat) # Returns the number of columns in your dataframe.
hist(simdat$age) # Returns a histogram of a column in your dataframe containing numerical data, in this case age. 
```

## Add a column to your dataframe

Often times, we will want to create new columns in our dataframe. This can be as simple as adding geographic metadata like country or state, or be a little more complex and use calculations made on data stored elsewhere in our dataframe. In the below chunk of code, we will add three new columns to our *simdat* dataframe: *state*, *bmi*, and *logbmi*. In each case, we will specify the new column using *$*, which specifies a column in a dataframe in the following way: *dataframe$column*. We will then assign this column new values using the *<-* assignment operator:

For example, in our dataset, we might be interested in calculating the body mass index (BMI) of patients. To do so, we will create a new column, *bmi*, which will take values from the *ht_cm* and *wt_kg* columns for that patient and plug them into the BMI equation. We will then create another new column, *log.bmi*, that contains the log-transformed bmi values we just created: 


```{r}
simdat$state <- "Colorado" # Creating a state column. 

# The above line of code creates the new column, 'state,' in our dataframe, 'simdat,' and fills every cell with the character "Colorado". Even though this column did not yet exist, we created it by assigning it values using the <- assignment syntax. 

simdat$bmi <- simdat$wt_kg/(simdat$ht_cm/100) #Creating a bmi column. 

# Above, we created a new column, bmi, in the simdat dataframe that contains each individual's body mass index (BMI), which is a function of their weight and height. In specifying this new column, we used the patient's height and weight data stored in separate columns in the dataframe, plugging them into the BMI equation. 

simdat$logbmi <- log10(simdat$bmi) #Creating a column of log-transformed bmi values. 

# In the above line, we used the function 'log10()', which log(base-10)-transforms numerical data passed to the function. We
# passed the data contained in the bmi column we just created to this function to log-transform it and store the results in the logbmi column. 
```

## Filter data

When working with our data, we often are interested in only a subset, such as that from a specific hospital. In R, there are a few different ways to subset our data in this way, including using base-R indexing syntax, the base-R *subset()* function, and the *filter()* function from the package *dplyr*. All of these methods accomplish the same thing, illustrating that there can be redundancies in R and among Packages. Below, we illustrate how each can be used to subset the *simdat* dataframe to create a new dataframe, *simdat.military*, which only contains data collected from Military Hospital: 
```{r, echo=FALSE}
require(dplyr)
```


```{r, results='hide',fig.keep='all'}
simdat.military <- simdat[simdat$hospital == "Military Hospital",]
# The above line of code uses the base-R indexing system: dataframe[row, column]. We specified the new dataframe, simdat.military, to be a subset of simdat, specifically those rows where the 'hospital' column contains a string exactly equal to "Military Hospital". By leaving the column entry after the "," blank, we told R to include all of the column originally contained in simdat.

# It is important to use == here instead of = because we are asking R to find values that exactly equal some string. The single = can be used in lieu of <- for assignment, but we are not trying to assign any values, but rather find them. 

simdat.military <- subset(simdat, hospital == "Military Hospital")
# The above line creates the same new dataframe, simdat.military, but uses the base-R function, subset(). 

simdat.military <- filter(simdat, hospital == "Military Hospital")
# The above line of code does the exact same thing, but using the filter() function from the dplyr Package. 

dim(simdat.military) # As you can see, the size of our dataframe has reduced compared to simdat, indicating the subsetting worked. 
```

What if we wanted to subset intead based on some numerical value? For example, what if we wanted to just use data from individuals 18 years-old or older? We can do that, too!

```{r, results='hide',fig.keep='all'}
# Indexing first: 
simdat.18 <- simdat[simdat$age>18,] #However, this line does NOT include individuals that are exactly 18 years-old...
simdat.18 <- simdat[simdat$age>=18,] # ...this one does. 

# subset():
simdat.18 <- subset(simdat, age >= 18)

# filter():
simdat.18 <- filter(simdat, age >= 18)
dim(simdat.18) # Looks like the subsetting was successful. 
```

## Summarize data using aggregate()

Perhaps one of the most common things you will want to do with your dataset is make summary tables. The tidyverse makes this quite simple in R, but does require syntax that is not always intuitive, including the piping operator: %>% 

In plain English, the piping operator means "and then" and is used to string together a series of commands to wrangle, re-shape, and summarize your data. In the below chunk of code, we will summarize the mean and standard deviation of patient BMI between each hospital and disease outcome (recovery or death). We will store this summary as a new dataframe, *outcome.summ*:

```{r, results='hide',fig.keep='all'}
# Look to the right for plain English translations. 

outcome.summ <- simdat %>% # To make a new dataframe called outcome.summ, first take simdat AND THEN...
  group_by(hospital, outcome) %>% # ... group together all of its data based on hospital and outcome AND THEN...
  summarise(bmi.mean = mean(bmi), bmi.sd = sd(bmi)) # ... summarize each group's BMI data, storing the mean in a column called "bmi.mean" and the standard deviation in a column called "bmi.sd". 
```

## Write a .csv file

Today, we have created several new dataframes from our original simdat dataframe. If we want to save these new dataframes as a .csv file, the function write.csv() will come in handy. In the example below, I will write our new BMI summary dataframe as a new .csv file:

```{r}
write.csv(outcome.summ, "bmi_summ_dat.csv", row.names = F)
# The row.names = F argument tells R to, when writing the .csv, to not include row number as a column in the spreadsheet. 
```

## Carol's as.Date() and ggplot section


```{r}
print("Congratulations!")
```

